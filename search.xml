<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>闭包实现倒计时程序</title>
      <link href="/2018/07/14/%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%E7%A8%8B%E5%BA%8F/"/>
      <url>/2018/07/14/%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="话不多说直接贴代码"><a href="#话不多说直接贴代码" class="headerlink" title="话不多说直接贴代码"></a>话不多说直接贴代码</h3><pre><code class="javascript">var dj = (function() {            return {                time: function() {                    // setTimeout 内部this 指向                    var This = this;                    if (This.miao &gt; 0) {                        This.timer = setTimeout(function() {                            This.miao = This.miao - 1;                            This.time();                        }, 1000);                    } else if (This.miao == 0) {                        console.log(&#39;时间到  倒计时结束的操作&#39;)                        // do somthing....                    }                    // 渲染数据到页面                    This.rander();                },                rander: function() {   //做页面的数据渲染                    miaoStr = this.miao + &quot;&quot;;                    if (miaoStr.length &lt;= 1) {                        this.sw.innerHTML = &quot;0&quot;;                        this.gw.innerHTML = miaoStr;                    } else if (miaoStr.length &gt; 1) {                        this.sw.innerHTML = miaoStr[0];                        this.gw.innerHTML = miaoStr[miaoStr.length - 1];                    }                },                stop: function(time) {                    clearInterval(this.timer);                    //返回倒计时停止时候的秒数                    return this.miao;                },                start: function(miao, gw, sw) {                    //参数说明：   miao:自定义多少秒倒计时   gw:从页面获取到的 倒计时“个位”元素对象     sw:  从页面获取到的 倒计时“      ”元素对象                    this.gw = gw;                    this.sw = sw;                    this.miao = miao;                    this.time();                }            }        })();</code></pre><a id="more"></a><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code class="javascript">//从页面获取  个位 十位 元素ID  用于渲染var gw = document.getElementById(&#39;gw&#39;)var sw = document.getElementById(&#39;sw&#39;)//启动倒计时dj.start(60, gw, sw)//停止倒计时dj.stop()</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的防抖和节流</title>
      <link href="/2018/07/14/debounce&amp;&amp;throttle/"/>
      <url>/2018/07/14/debounce&amp;&amp;throttle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流是比较好的解决方案。</p></blockquote><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>防抖即将多次操作合并一次执行，若持续触发 计时器清零 ，按照最后一个 操作去做</p><pre><code class="javascript">function debounce(fn, delayTime) {  console.log(&#39;进来了&#39;)  let timer = null  return function () {    if (timer) {      clearTimeout(timer) // 如果有定时器 每次都清除    }    timer = setTimeout(() =&gt; {      fn()    }, delayTime)  }}</code></pre><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流的策略是，固定周期内，只执行一次动作，若有新事件触发，不执行。周期结束后，又有事件触发，开始新的周期。 节流策略也分前缘和延迟两种。与 debounce 类似，延迟是指 周期结束后执行动作，前缘是指执行动作后再开始周期。</p><pre><code class="javascript">function throttle(func, delay) {  let run = true  return function () {    if (!run) {      return // 如果开关关闭了，那就直接不执行下边的代码    }    run = false // 持续触发的话，run一直是false，就会停在上边的判断那里    setTimeout(() =&gt; {      func.apply(this, arguments)      run = true // 定时器到时间之后，会把开关打开，我们的函数就会被执行    }, delay)  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise 学习笔记（全）</title>
      <link href="/2018/03/13/Promise-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%A8%EF%BC%89/"/>
      <url>/2018/03/13/Promise-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Promise-学习笔记"><a href="#Promise-学习笔记" class="headerlink" title="Promise  学习笔记"></a>Promise  学习笔记</h3><h3 id="释义"><a href="#释义" class="headerlink" title="释义:"></a><strong>释义:</strong></h3><p>1.用于异步计算</p><p>2.一个promise 表示一个现在，将来或用不可能使用的值 ( 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。)</p><p>3.可以在对象之间传递和操作promise ，帮助我们处理队列</p><a id="more"></a><h3 id="异步回调的四个问题"><a href="#异步回调的四个问题" class="headerlink" title="异步回调的四个问题:"></a><strong>异步回调的四个问题:</strong></h3><ol><li>嵌套层次很深，容易陷入回调地域 ，很难维护  </li><li>无法正常使用 return  和  throw</li><li>无法正常检索堆栈信息，因为每一次回调都是系统层面上的新的堆栈 。</li><li>在多个回调之间难以建立联系。</li></ol><h3 id="Promise-结构"><a href="#Promise-结构" class="headerlink" title="Promise 结构:"></a><strong>Promise 结构:</strong></h3><pre><code class="javascript">new Promise(    //执行器 executor    function (resolve,reject) {        //一段耗时很长的异步操作        resolve() ; //数据处理完成        reject() ; //数据处理出错    }).then(function A(){    //成功 下一步},function B(){    // 失败，做相应的处理})</code></pre><h6 id="1-Promise-是一个代理对象，它和原先要进行的操作并无关系。只是将原来操作放入了executor"><a href="#1-Promise-是一个代理对象，它和原先要进行的操作并无关系。只是将原来操作放入了executor" class="headerlink" title="1.Promise 是一个代理对象，它和原先要进行的操作并无关系。只是将原来操作放入了executor"></a>1.Promise 是一个代理对象，它和原先要进行的操作并无关系。只是将原来操作放入了<code>executor</code></h6><h6 id="2-它通过引入一个回调，避免更多的回调"><a href="#2-它通过引入一个回调，避免更多的回调" class="headerlink" title="2.它通过引入一个回调，避免更多的回调"></a>2.它通过引入一个回调，避免更多的回调</h6><h3 id="Promise三个状态"><a href="#Promise三个状态" class="headerlink" title="*Promise三个状态 *"></a>*<em>Promise三个状态 *</em></h3><ol><li><code>pending</code> 待定状态</li><li>如果调用 <code>resolve()</code> 就进入  <code>fulfilled</code> 实现 操作成功状态</li><li>如果 <code>reject()</code> 就进入 <code>rejected</code> 被否决状态 操作失败</li></ol><p>当 promise 状态发生改变的时候，就会立即触发<code>.then()</code>离得响应函数，处理后续步骤</p><p>Promise 状态一经改变就不会改变</p><p>执行流程图  </p><p><img src="./1520911191668.png" alt="执行流程图"></p><h3 id="then-函数"><a href="#then-函数" class="headerlink" title=".then()函数"></a><strong>.then()函数</strong></h3><pre><code class="javascript">// 假如在.then()的函数里面不返回新的Promise，会怎样？// https://www.imooc.com/video/16616console.log(&#39;here we go&#39;);new Promise(resolve =&gt; {    setTimeout( () =&gt; {        resolve(&#39;hello&#39;);    }, 2000);})    .then( value =&gt; {        console.log(value);        console.log(&#39;everyone&#39;);        (function () {            return new Promise(resolve =&gt; {                setTimeout(() =&gt; {                    console.log(&#39;Mr.Laurence&#39;);                    resolve(&#39;Merry Xmas&#39;);                }, 2000);            });        }());        return false;    })    .then( value =&gt; {        console.log(value + &#39; world&#39;);    });结果：here we gohelloeveryonefalse worldMr.Laurence</code></pre><p><code>.then()</code>  接受两个函数作为参数，分别代表 <code>fulfilled</code> 和 ‘rejected’</p><p><code>.then()</code> 返回一个新的Promise 实例，所以它可以链式调用</p><p>当前面的    <code>Promise</code> 状态改变时，<code>.then()</code> 根据其最终状态，选择特定的状态响应函数执行 。</p><p>状态响应函数可以反悔新的<code>Promise</code> ，或其它值</p><p>如果返回新的 <code>Promise</code> ，那么下一级 <code>.then()</code> 会在新 Promise 状态改变之后执行</p><p>如果返回其它任何值，则会立即执行下一级 <code>.then()</code>   </p><h4 id="then-里面有-then-的情况"><a href="#then-里面有-then-的情况" class="headerlink" title=".then() 里面有 .then() 的情况"></a>.then() 里面有 .then() 的情况</h4><ol><li><p>因为 <code>.then()</code> 返回的还是Promise 实例</p></li><li><p>外层的 <code>.then</code> 会等到 里面的<code>.then()</code>执行完成 再执行</p></li><li><p>对于我们来书，此时最好将其展开，会更好读</p></li></ol><pre><code class="javascript">// 嵌套.then()// https://www.imooc.com/video/16618console.log(&#39;start&#39;);new Promise( resolve =&gt; {    console.log(&#39;Step 1&#39;);    setTimeout(() =&gt; {        resolve(100);    }, 1000);})    .then( value =&gt; {        return new Promise(resolve =&gt; {            console.log(&#39;Step 1-1&#39;);            setTimeout(() =&gt; {                resolve(110);            }, 1000);        })            .then( value =&gt; {                console.log(&#39;Step 1-2&#39;);                return value;            })            .then( value =&gt; {                console.log(&#39;Step 1-3&#39;);                return value;            });    })    .then(value =&gt; {        console.log(value);        console.log(&#39;Step 2&#39;);    });结果：startstep 1step 1-1step 1-2step 1-3110step 2</code></pre><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a><strong>思考：</strong></h3><p>以下问题出自：<br><a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="noopener">原文：We have a problem with promises</a><br><a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/" target="_blank" rel="noopener">FEX 中文翻译</a><br><a href="https://www.imooc.com/video/16619/0" target="_blank" rel="noopener">慕课网视频讲解</a></p><h5 id="以下四种Promise-的区别是什么呢？"><a href="#以下四种Promise-的区别是什么呢？" class="headerlink" title="以下四种Promise 的区别是什么呢？"></a>以下四种Promise 的区别是什么呢？</h5><pre><code class="javascript">doSomething().then(function () {  return doSomethingElse();});doSomething().then(function () {  doSomethingElse();});doSomething().then(doSomethingElse());doSomething().then(doSomethingElse);</code></pre><h5 id="答案-："><a href="#答案-：" class="headerlink" title="答案 ："></a>答案 ：</h5><pre><code class="javascript">第一题：doSomething().then(function () {  return doSomethingElse();}).then(finalHandler);doSomething|-----------------|                  doSomethingElse(undefined)                  |------------------|                                     finalHandler(resultOfDoSomethingElse)                                     |------------------|第二题：doSomething().then(function () {  doSomethingElse();}).then(finalHandler);doSomething|-----------------|                  doSomethingElse(undefined)                  |------------------|                  finalHandler(undefined)                  |------------------|第三题：doSomething().then(doSomethingElse())  .then(finalHandler);doSomething|-----------------|doSomethingElse(undefined)|---------------------------------|                  finalHandler(resultOfDoSomething)                  |------------------|第四题：doSomething().then(doSomethingElse)  .then(finalHandler);doSomething|-----------------|                  doSomethingElse(resultOfDoSomething)                  |------------------|                                     finalHandler(resultOfDoSomethingElse)                                     |------------------|</code></pre><h4 id="版权说明：以上均为-慕课网课程：Promise-入门-学习笔记-如有侵权联系我删除"><a href="#版权说明：以上均为-慕课网课程：Promise-入门-学习笔记-如有侵权联系我删除" class="headerlink" title="版权说明：以上均为 慕课网课程：Promise 入门 学习笔记,如有侵权联系我删除"></a>版权说明：以上均为 <a href="https://www.imooc.com/learn/949" target="_blank" rel="noopener">慕课网课程：Promise 入门</a> 学习笔记,如有侵权<a href="18735443767">联系我</a>删除</h4>]]></content>
      
      
      <categories>
          
          <category> EcmaJs6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css3实现背景毛玻璃效果</title>
      <link href="/2018/03/06/Css3%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C/"/>
      <url>/2018/03/06/Css3%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h5 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h5><pre><code class="javascript">let asdasd</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
            <tag> css3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Es6学习总结 </title>
      <link href="/2017/12/06/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/06/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="let-特性"><a href="#let-特性" class="headerlink" title="let 特性"></a>let 特性</h3><ol><li><p>不可以重复申明</p></li><li><p>没有预解析过程（即变量声明提前）</p></li><li><p>块级作用域 ：一个变量或者函数只有在该区域才起作用</p><pre><code class="javascript">{  //块级作用域  let a = 1  console.log(a)}//举个例子：for循环依次输出 0~10for (var i = 0; i &lt; 10; i++) {  setTimeout(function () {    console.log(i) //解析：上述结果 输出10次i ，原因为每次for循环结束后 setTimeout还在走，所以输出的i还是全局的i，所以一直是10  }, 0)}//我们若想依次输出0~10 我们可以使用一个闭包函数， 在闭包函数中会形成一个作用域，将i以形参的形式传入，这样每次执行循环的时候，变量就会存在于闭包作用域中。for (var i = 0; i &lt; 10; i++) {  ;(function (i) {    setTimeout(function (argument) {      console.log(i) // 0,1,2,3,4,5,6,7,8,9,10    })  })(i)}//在ecma6 中 我们可以使用let 来实现 ,let 将循环变成一个块级作用域，第一次循环完成之后，i就是那个0for (let i = 0; i &lt; 10; i++) {  setTimeout(function (argument) {    console.log(i) // 0,1,2,3,4,5,6,7,8,9,10  })}</code></pre><a id="more"></a></li><li><p>暂存死区 相似于 预解析</p></li></ol><h2 id="常量声明–const"><a href="#常量声明–const" class="headerlink" title="常量声明–const"></a><h6 style="color:green">常量声明–const</span></h2><p><b >const 简介:</b>防止命名冲突 存一些东西用于对比 声明后不能被修改(变量值不可修改，若是一个对象是可以被修改的)</p><pre><code class="javascript">const a = 1console.log(a) //1// const a = 2 ;console.log(a) //报错const b = { name: 1 }console.log(a.name)ab.name = 2console.log(a) // {name:2}</code></pre><h2 id="变量的“解构”赋值"><a href="#变量的“解构”赋值" class="headerlink" title="变量的“解构”赋值"></a><h6 style="color:green">变量的<b>“解构”</b>赋值</span></h2><p><b >解构赋值简介:</b> Es6 允许按照一定的模式，通过一定的格式将数组和对象中的值提取出来，赋给变量</p><pre><code class="javascript">&#39;use strict&#39;//数组的解构赋值 ： 按照对应的顺序解构var arr = [1, 2, 3]var [a, b, c] = arrconsole.log(a, b, c) // 1,2,3var arr1 = [1, [2, 3]]var [d, [e, f]] = arrconsole.log(d, e, f) // 1,2,3//对象的解构赋值 ： 按照 对象的属性名称进行解构   和顺序无关 ,方便从对象里面拿到对应的值var obj = {  foo: function () {},  o: {},  arr: [],  str: &#39;abc&#39;,}var { foo, o, arr, str } = objconsole.log(foo, o, arr, str) // function(){}  {}  []  abc//值的交换var x = 1var y = 2var [x, y] = [y, x]console.log(x, y) //2 1</code></pre><h2 id="ES6-字符串的扩展"><a href="#ES6-字符串的扩展" class="headerlink" title="ES6 字符串的扩展"></a><h6 style="color:green">ES6 字符串的扩展</span></h2><pre><code class="javascript">/*模板字符串*/var name = &#39;狮父&#39;var age = &#39;18&#39;//传统字符串拼接做法：var str = &#39;你的名字是：&#39; + name + &#39;你的年龄是&#39; + ageconsole.log(str)//使用模板字符串varstr = `你的名字是${name},你的年龄是${age}` //注意：使用反引号 `do something` 来包含,{}中可以进行运算 和 对象.属性/*字符串复制str.repeat(num);*/var str = aconsole.log(a.repeat(10)) // aaaaaaaaaa/*字符串的查找 str.includes()*/var str = &#39;abc&#39;console.log(str.includes(&#39;a&#39;)) //true/*查找对应字符是否在首部或者尾部*/var str = &#39;shifu&#39;str.startsWith(&#39;shi&#39;) // true ;str.endsWith(&#39;u&#39;) //true ;</code></pre><h2 id="ES6-数值的扩展"><a href="#ES6-数值的扩展" class="headerlink" title="ES6 数值的扩展"></a><h6 style="color:green">ES6 数值的扩展</span></h2><pre><code class="javascript">/*二进制和八进制表示法:ES6提供使用前缀Ob和Oo表示 二进制八进制*/var a = 0b11 // 3var a = 0o11 // 9/*Math 方法的扩展*/// 取掉小数点var num = 1.234console.log(Math.trunc(num)) // 1//判断一个数字是正数负数,正0还是0var num1 = 0console.log(Math.sign(0)) //0 ;console.log(Math.sign(-0)) //  -0 ;//勾股定理  返回所有平方和的平方根console.log(Math.hypot(3, 4)) //5</code></pre><h2 id="ES6-数组的扩展"><a href="#ES6-数组的扩展" class="headerlink" title="ES6 数组的扩展"></a><h6 style="color:green">ES6 数组的扩展</span></h2><pre><code class="javascript">/*转数组*/&#39;use strict&#39;var divs = document.getElementsByTagName(&#39;div&#39;) //获取到类数组//es5做法var ele = [].slice.call(&#39;div&#39;) // []//es6 做法var eles = Array.from(divs) //[]//也可以字符串转数组var str = &#39;abc&#39;console.log(Array.from(str)) // [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]//将参数转换成数组   es5中:var arr = new Array(5) ,arr.length == 5 ;var arr = Array.of(a, b, c, d, e)console.log(arr) // [] ;/*数组查找元素*///语法:arr.find()   arr.findIndex()//参数:1.回掉函数  2.回掉函数中的this指向//执行过程:遍历整个数组,遍历的过程中调用回调函数，如果回调函数的返回值为true，则返回当前正在遍历的元素，如果所有的元素都不符合条件则返回undefinedvar arr = [1, 2, 3, 4, 5]var n = arr.find(function (value, index, ar) {  console.log(value) // 遍历的当前值  1  console.log(index) // 遍历值所处的位置索引 0  console.log(ar) // 当前正在遍历的数组本身  [1,2,3,4,5]})</code></pre><p>/<em>new</em>/</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> javascript 事件</title>
      <link href="/2017/08/06/javascript-%E4%BA%8B%E4%BB%B6/"/>
      <url>/2017/08/06/javascript-%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><h4 id="一、事件的种类"><a href="#一、事件的种类" class="headerlink" title="一、事件的种类"></a>一、事件的种类</h4></blockquote><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p><code>click</code>  <code>dbclick</code>  <code>mouseup</code>  <code>mousedown</code> <code>mousemove</code> <code>mouseover</code> <code>mouseenter</code>  <code>mouseout</code> <code>mouseleave</code></p><h4 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件"></a>滚轮事件</h4><p><code>wheel</code></p><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p><code>keydown</code>  <code>keypress</code>  <code>keyup</code></p><a id="more"></a><h4 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h4><p><code>abort</code> <code>error</code> <code>load</code> <code>loadstart</code>  <code>loadend</code>  <code>progress</code>  <code>timeout</code>   </p><h4 id="拖拽事件"><a href="#拖拽事件" class="headerlink" title="拖拽事件"></a>拖拽事件</h4><p><code>drag</code>  <code>dragstart</code>  <code>dragend</code>  <code>dragenter</code> <code>dragover</code> <code>dragleave</code>  <code>drop</code></p><h4 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h4><p><code>touchstart</code>  <code>touchend</code>  <code>toumove</code>  <code>touchcancel</code></p><h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><p><code>input</code>  <code>select</code>  <code>change</code>  <code>reset</code> <code>submit</code></p><h4 id="文档事件"><a href="#文档事件" class="headerlink" title="文档事件"></a>文档事件</h4><p><code>load</code> <code>error</code> <code>pageshow</code> <code>pagelive</code> <code>DOMContentLoaded</code> <code>readystatechange</code> <code>scroll</code> <code>resize</code> <code>copy</code> <code>cut</code> <code>paste</code> <code>focus</code> <code>focusin</code> <code>focusout</code>  <code>blur</code>  <code>hashchange</code> <code>popstate</code></p><blockquote><h4 id="二、事件传播的三个阶段"><a href="#二、事件传播的三个阶段" class="headerlink" title="二、事件传播的三个阶段"></a>二、事件传播的三个阶段</h4></blockquote><h5 id="1-捕获阶段"><a href="#1-捕获阶段" class="headerlink" title="1.捕获阶段"></a>1.捕获阶段</h5><p>从 <code>window</code> 对象传导到目标阶段的过程</p><h5 id="2-目标阶段"><a href="#2-目标阶段" class="headerlink" title="2.目标阶段"></a>2.目标阶段</h5><p>当事件在目标节点出发的过程</p><h5 id="3-冒泡阶段"><a href="#3-冒泡阶段" class="headerlink" title="3.冒泡阶段"></a>3.冒泡阶段</h5><p>从目标阶段传导回<code>window</code>对象的过程</p><h4 id="代码示意："><a href="#代码示意：" class="headerlink" title="代码示意："></a>代码示意：</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;   &lt;p&gt;Click Me&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var phases = {   1: &#39;capture&#39;, //捕获阶段   2: &#39;target&#39;, //当前   3: &#39;bubble&#39; //冒泡 }; var div = document.querySelector(&#39;div&#39;); var p = document.querySelector(&#39;p&#39;); div.addEventListener(&#39;click&#39;, callback, true); // 捕获 p.addEventListener(&#39;click&#39;, callback, true); //target div.addEventListener(&#39;click&#39;, callback, false); // 冒泡 p.addEventListener(&#39;click&#39;, callback, false);  // target function callback(event) {   console.log(event)   var tag = event.currentTarget.tagName;   var phase = phases[event.eventPhase];   console.log(&quot;Tag: &#39;&quot; + tag + &quot;&#39;. EventPhase: &#39;&quot; + phase + &quot;&#39;&quot;); }&lt;/script&gt;&lt;/html&gt;</code></pre><h4 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h4><p><img src="https://app.yinxiang.com/shard/s72/res/8d53d1e2-c43a-408c-9e3f-a10bef9354ae" alt="Alt text"></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><span style="color:red">注意：</span></h4><h5 id="用户点击网页的时候，浏览器总是假定click事件的目标节点，就是点击位置的嵌套最深的那个节点（嵌套在-lt-div-gt-节点的-lt-p-gt-节点）。所以，-lt-p-gt-节点的捕获阶段和冒泡阶段，都会显示为target阶段。"><a href="#用户点击网页的时候，浏览器总是假定click事件的目标节点，就是点击位置的嵌套最深的那个节点（嵌套在-lt-div-gt-节点的-lt-p-gt-节点）。所以，-lt-p-gt-节点的捕获阶段和冒泡阶段，都会显示为target阶段。" class="headerlink" title="用户点击网页的时候，浏览器总是假定click事件的目标节点，就是点击位置的嵌套最深的那个节点（嵌套在&lt;div&gt;节点的&lt;p&gt;节点）。所以，&lt;p&gt;节点的捕获阶段和冒泡阶段，都会显示为target阶段。"></a>用户点击网页的时候，浏览器总是假定click事件的目标节点，就是点击位置的嵌套最深的那个节点（嵌套在<code>&lt;div&gt;</code>节点的<code>&lt;p&gt;</code>节点）。所以，<code>&lt;p&gt;</code>节点的捕获阶段和冒泡阶段，都会显示为target阶段。</h5><blockquote><h4 id="三、事件代理"><a href="#三、事件代理" class="headerlink" title="三、事件代理"></a>三、事件代理</h4></blockquote><h5 id="由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。"><a href="#由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。" class="headerlink" title="由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。"></a>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</h5><pre><code class="html"> &lt;ul&gt;   &lt;li&gt;&lt;/li&gt;   &lt;li id=&quot;lis&quot;&gt;     &lt;p onclick=&quot;pClick()&quot;&gt;click me&lt;/p&gt;   &lt;/li&gt;   &lt;li&gt;&lt;/li&gt;   &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;</code></pre><pre><code class="javascript"> var ul = document.querySelector(&#39;ul&#39;); var lis = document.querySelector(&#39;#lis&#39;); // lis 的监听函数 lis.addEventListener(&#39;click&#39;, (event) =&gt; {   console.log(&#39;这个是li的第一个监听函数&#39;)   event.stopPropagation()  // 阻止当前事件向上冒泡  ，故 ul监听事件不执行   event.stopImmediatePropagation()  //  event.stopPropagation只能阻止当前监听事件不冒，但是阻止不了其他监听事件 ，所以使用    event.stopImmediatePropagation }) lis.addEventListener(&#39;click&#39;, (event) =&gt; {   console.log(&#39;这个是li的第二个监听函数&#39;) }) // p 元素的监听函数 function pClick() {   console.log(&#39;这个是P元素的监听函数&#39;) } //   ul监听函数 ul.addEventListener(&#39;click&#39;, (event) =&gt; {   console.log(&#39;ul的第一个监听函数&#39;)   // 事件代理 处理 子元素 p 的点击   // if (event.target.tagName.toLowerCase() == &quot;p&quot;) {   //   // p节点触发   //   console.log(&#39;点击了P元素&#39;)   //   // } }) ul.addEventListener(&#39;click&#39;, (event) =&gt; {   console.log(&#39;ul的第二个监听函数&#39;) })</code></pre><h4 id="stopPropagation-和-stopImmediatePropagation-区别-："><a href="#stopPropagation-和-stopImmediatePropagation-区别-：" class="headerlink" title="stopPropagation  和  stopImmediatePropagation 区别 ："></a><code>stopPropagation</code>  和  <code>stopImmediatePropagation</code> 区别 ：</h4><p>　　在事件处理程序中，每个事件处理程序中间都会有一个event对象，而这个event对象有两个方法，一个是stopPropagation方法，一个是stopImmediatePropagation方法，两个方法只差一个Immediate，这里就说说这两个方法的区别</p><p>　　1、<code>stopImmediatePropagation</code>方法：</p><p>　　　　stopImmediatePropagation方法作用在当前节点以及事件链上的所有后续节点上，目的是在执行完当前事件处理程序之后，停止当前节点以及所有后续节点的事件处理程序的运行</p><p>　　2、<code>stopPropagation</code>方法</p><p>　　　　stopPropagation方法作用在后续节点上，目的在执行完绑定到当前元素上的所有事件处理程序之后，停止执行所有后续节点的事件处理程序</p><hr><p>　从概念上讲，在调用完stopPropagation函数之后，就会立即停止对后续节点的访问，但是会执行完绑定到当前节点上的所有事件处理程序；而调用stopImmediatePropagation函数之后，除了所有后续节点，绑定到当前元素上的、当前事件处理程序之后的事件处理程序就不会再执行了</p><hr>#### 版权说明：阮一峰大神 [javascript标准参考教程](http://javascript.ruanyifeng.com/dom/event.html#toc8)超载的笨鸟 [浅谈javascript中stopImmediatePropagation函数和stopPropagation函数的区别](http://www.cnblogs.com/dqsBK/p/6287907.html)]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue  导航</title>
      <link href="/2017/05/23/vue-%E5%AF%BC%E8%88%AA/"/>
      <url>/2017/05/23/vue-%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习工具<br><img src="https://app.yinxiang.com/shard/s72/res/61f82848-a4be-4740-bef7-325f4d827e76" alt="Alt text"></p></blockquote><blockquote><p>三个特点</p></blockquote><ul><li>响应式-双响数据绑定</li><li>单文件组件</li><li><a id="more"></a></li></ul><blockquote><p>脚手架安装</p></blockquote><p><img src="https://app.yinxiang.com/shard/s72/res/d827d45b-e1b4-485e-8267-c0d68e138443" alt="Alt text"></p><ol><li>当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。<strong>当这些数据改变时，视图会进行重渲染。</strong></li></ol><pre><code class="javascript">// 我们的数据对象var data = { a: 1 }// 该对象被加入到一个 Vue 实例中var vm = new Vue({  data: data})// 他们引用相同的对象！vm.a === data.a // =&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // =&gt; 2// ... 反之亦然data.a = 3vm.a // =&gt; 3</code></pre><blockquote><p>生命周期：每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。</p></blockquote><p>比如 created 钩子可以用来在一个实例被创建之后执行代码：</p><pre><code class="javascript">new Vue({  data: {    a: 1  },  created: function () {    // `this` 指向 vm 实例    console.log(&#39;a is: &#39; + this.a)  }})// =&gt; &quot;a is: 1&quot;</code></pre><p><strong>* 也有一些其它的钩子，在实例生命周期的不同场景下调用，如 mounted、updated、destroyed。钩子的 this 指向调用它的 Vue 实例。*</strong></p><p><img src="https://app.yinxiang.com/shard/s72/res/60a600bf-fb6b-4b92-9641-094df5ba02e1" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端web页面调试方法</title>
      <link href="/2017/05/07/web-phone-Debug/"/>
      <url>/2017/05/07/web-phone-Debug/</url>
      
        <content type="html"><![CDATA[<h1 style="color:green;width: 100%;text-align: center ">移动端web调试方法</h1>### *前言<a id="more"></a><blockquote><div style="color:#D00750">移动端调试不同于桌面端调试，在桌面时代，chrome的调试器已经无比强大。但是在手机上调试web页面就没有这么原始的方式了。  本文就如何调试移动端web页面，借鉴了一些博文和目前市面上好用的工具，针对移动端web页面以及APP内嵌webview页面如何调试做了一个试用和整理。  先谈谈需求。  最理想的方式是什么？</div></blockquote><h4 id="一-ios设备下"><a href="#一-ios设备下" class="headerlink" title="一.ios设备下"></a>一.ios设备下</h4><ol><li>H5页面</li><li>webview页面</li></ol><h4 id="二-安卓设备"><a href="#二-安卓设备" class="headerlink" title="二.安卓设备"></a>二.安卓设备</h4><ol><li>H5页面</li><li>webview页面</li></ol><p> 最理想的状态就是在上述四种情况下，H5页面在各种浏览器下都可以进行调试，且调试的方式跟PC chrome类似，包含js断点调试。webview页面在微信以及公司的APP产品内可以进行类似PC chrome类似的调试方式，包含js断点调试。</p><hr><hr><h3 id="IOS-设备"><a href="#IOS-设备" class="headerlink" title="IOS 设备"></a><span style="color:red">IOS 设备</span></h3><blockquote><p>1、 ios safari + mac safari + iphone真机</p></blockquote><h4 id="调试safari浏览器的H5页面"><a href="#调试safari浏览器的H5页面" class="headerlink" title="调试safari浏览器的H5页面"></a>调试safari浏览器的H5页面</h4><p>启用功能：</p><p>手机端：设置 → Safari → 高级 → Web 检查器 → 开。</p><p>mac端：Safari → 偏好设置 → 高级 → 在菜单栏中显示“开发”菜单。</p><p>然后就可以在电脑端调试iphone上的safari浏览器上的样式。在调试器及资源里可以对js打断点。操作方式跟chrome的调试器一样。不同的是我们是在手机上对页面进行操作，触发断点环境会更真实。</p><p>若在js中埋入一些console，在IOS真机上执行一些操作，mac端safari上调试器能打印，这能极大的方便复杂手势的一些操作。</p><h4 id="优点：包含js断点功能，调试方式跟桌面端chrome几乎一样"><a href="#优点：包含js断点功能，调试方式跟桌面端chrome几乎一样" class="headerlink" title="优点：包含js断点功能，调试方式跟桌面端chrome几乎一样"></a>优点：包含js断点功能，调试方式跟桌面端chrome几乎一样</h4><h4 id="缺点：只能在手机上的safari浏览器上操作，不能覆盖其他手机环境，另外也不支持webview的调试。"><a href="#缺点：只能在手机上的safari浏览器上操作，不能覆盖其他手机环境，另外也不支持webview的调试。" class="headerlink" title="缺点：只能在手机上的safari浏览器上操作，不能覆盖其他手机环境，另外也不支持webview的调试。"></a>缺点：只能在手机上的safari浏览器上操作，不能覆盖其他手机环境，另外也不支持webview的调试。</h4><blockquote><p>2、 万金油 weinre + 真机</p></blockquote><h4 id="调试任意浏览器的H5页面以及webview页面"><a href="#调试任意浏览器的H5页面以及webview页面" class="headerlink" title="调试任意浏览器的H5页面以及webview页面"></a>调试任意浏览器的H5页面以及webview页面</h4><p>使用场景：有些时候样式在桌面chrome模拟是好的，但是在部分webview或者真机上就有问题。</p><h4 id="第一步：npm-install-g-weinre"><a href="#第一步：npm-install-g-weinre" class="headerlink" title=". 第一步：npm install -g weinre"></a>. 第一步：npm install -g weinre</h4><h4 id="第二步：weinre-–boundHost-xx-ip"><a href="#第二步：weinre-–boundHost-xx-ip" class="headerlink" title=". 第二步：weinre –boundHost xx ip"></a>. 第二步：weinre –boundHost xx ip</h4><h4 id="类似于weinre-–boundHost-172-16-28-162"><a href="#类似于weinre-–boundHost-172-16-28-162" class="headerlink" title=". 类似于weinre –boundHost 172.16.28.162"></a>. 类似于weinre –boundHost 172.16.28.162</h4><h4 id="第三步：此时weinre会返回一个可用的地址"><a href="#第三步：此时weinre会返回一个可用的地址" class="headerlink" title=". 第三步：此时weinre会返回一个可用的地址"></a>. 第三步：此时weinre会返回一个可用的地址</h4><pre><code class="javscript">2015-12-14T03:58:50.349Z weinre: starting server at http://10.1.2.77:8080</code></pre><p>也可以指定端口号</p><h4 id="weinre-httpPort-8081-boundHost-172-16-28-162"><a href="#weinre-httpPort-8081-boundHost-172-16-28-162" class="headerlink" title="weinre --httpPort 8081 --boundHost 172.16.28.162"></a><code>weinre --httpPort 8081 --boundHost 172.16.28.162</code></h4><h4 id="第四步：可以访问之前weinre分配过来的地址，进入后在页面最上部分可以看到-Access-Points-下的-debug-client-user-interface-http-10-1-2-77-8080-client-anonymous"><a href="#第四步：可以访问之前weinre分配过来的地址，进入后在页面最上部分可以看到-Access-Points-下的-debug-client-user-interface-http-10-1-2-77-8080-client-anonymous" class="headerlink" title=". 第四步：可以访问之前weinre分配过来的地址，进入后在页面最上部分可以看到 Access Points 下的 debug client user interface http://10.1.2.77:8080/client/#anonymous"></a>. 第四步：可以访问之前weinre分配过来的地址，进入后在页面最上部分可以看到 <code>Access Points</code> 下的 <code>debug client user interface http://10.1.2.77:8080/client/#anonymous</code></h4><p><img src="http://cdn1.showjoy.com/images/9a/9a259c3bbf5d438399842c11d53054c9.png" alt="效果"></p><p>这是之后要点击的链接 ，我们先往当前网页下方看。可以看到 <code>Target Script</code>栏目</p><p><img src="http://cdn1.showjoy.com/images/ad/add8ce371e0e4f52898fe4f652427f50.png" alt="效果"></p><p>我们需要将<code>Example</code>的<code>script</code>标签复制粘贴到需要调试的项目中去。</p><h4 id="第五步：开启本地静态服务器（XMAPP等），进入到需要调试的项目的页面，例如http-10-1-2-77-8000-index-html我是利用nodejs开的一个小型服务器。"><a href="#第五步：开启本地静态服务器（XMAPP等），进入到需要调试的项目的页面，例如http-10-1-2-77-8000-index-html我是利用nodejs开的一个小型服务器。" class="headerlink" title=". 第五步：开启本地静态服务器（XMAPP等），进入到需要调试的项目的页面，例如http://10.1.2.77:8000/index.html我是利用nodejs开的一个小型服务器。"></a>. 第五步：开启本地静态服务器（XMAPP等），进入到需要调试的项目的页面，例如<code>http://10.1.2.77:8000/index.html</code>我是利用<code>nodejs</code>开的一个小型服务器。</h4><p><img src="http://cdn1.showjoy.com/images/d5/d53d31ba1bcd41749446ae158e923ed8.png" alt="XI"></p><h4 id="第六步：此时可以回到第四步中的weine分配给你的地址，"><a href="#第六步：此时可以回到第四步中的weine分配给你的地址，" class="headerlink" title=". 第六步：此时可以回到第四步中的weine分配给你的地址，"></a>. 第六步：此时可以回到第四步中的weine分配给你的地址，</h4><p><img src="http://cdn1.showjoy.com/images/42/42eadf2d9af545629e14387a9c6c64bf.png" alt="SA"><br>点击第一条<code>debug client user interface: http://10.1.2.77:8080/client/#anonymous</code>,进入预备调试页面。</p><h4 id="第七步：在预备调试页面我们可以看到"><a href="#第七步：在预备调试页面我们可以看到" class="headerlink" title=". 第七步：在预备调试页面我们可以看到"></a>. 第七步：在预备调试页面我们可以看到</h4><p><img src="http://cdn1.showjoy.com/images/ca/ca2a26ecf08d4eca807ea1ec2374eee9.png" alt="asd"><br><code>Targets</code>下有一条可以选择的调试页面，对应着刚刚在本地静态服务器中打开的页面。但是这个页面是PC的，现在我们通过手机（浏览器、APP、微信等）进入这个项目ip地址<code>http://10.1.2.77:8000/index.html</code><br>此时预备调试页面将会出现两条可调试地址<br><img src="http://cdn1.showjoy.com/images/42/426b2c9ab5504cc18c77b1da504e7270.png" alt="as"><br>选择手机端进入后新增的地址。</p><h4 id="第八步：点开链接后链接状态从蓝色变成绿色，然后再点击页面左上角的Element按钮。"><a href="#第八步：点开链接后链接状态从蓝色变成绿色，然后再点击页面左上角的Element按钮。" class="headerlink" title=".第八步：点开链接后链接状态从蓝色变成绿色，然后再点击页面左上角的Element按钮。"></a>.第八步：点开链接后链接状态从蓝色变成绿色，然后再点击页面左上角的Element按钮。</h4><p><img src="http://cdn1.showjoy.com/images/ae/ae11cb7dc7034bc4981503af603c6300.png" alt="a"><br>现在就可以在pc端调试，手机端直接显示修改的变化啦。</p><h4 id="优点：为何称weinre为万金油呢？因为只要在需要调试的项目的文件中引入weinre给出的-lt-scrip-标签，再配合本地静态服务器的ip。可以在任何ios或安卓机型的包括浏览器和app的webview中去调试。"><a href="#优点：为何称weinre为万金油呢？因为只要在需要调试的项目的文件中引入weinre给出的-lt-scrip-标签，再配合本地静态服务器的ip。可以在任何ios或安卓机型的包括浏览器和app的webview中去调试。" class="headerlink" title="优点：为何称weinre为万金油呢？因为只要在需要调试的项目的文件中引入weinre给出的&lt;scrip 标签，再配合本地静态服务器的ip。可以在任何ios或安卓机型的包括浏览器和app的webview中去调试。"></a>优点：为何称weinre为万金油呢？因为只要在需要调试的项目的文件中引入weinre给出的&lt;scrip 标签，再配合本地静态服务器的ip。可以在任何ios或安卓机型的包括浏览器和app的webview中去调试。</h4><h4 id="缺点：-weinre不支持js的断点调试，这是一个缺憾，并且要在项目中引入额外的调试js标签。"><a href="#缺点：-weinre不支持js的断点调试，这是一个缺憾，并且要在项目中引入额外的调试js标签。" class="headerlink" title="缺点： weinre不支持js的断点调试，这是一个缺憾，并且要在项目中引入额外的调试js标签。"></a>缺点： weinre不支持js的断点调试，这是一个缺憾，并且要在项目中引入额外的调试js标签。</h4><p>但是对于js断点，可以在js逻辑中埋入console，然后在手机端真实操作，再在pc端的调试器中查看打印信息这种方式来代替。</p><blockquote><p>3、MIHTool</p></blockquote><h4 id="调试chrome-safari浏览器的H5页面"><a href="#调试chrome-safari浏览器的H5页面" class="headerlink" title="调试chrome safari浏览器的H5页面"></a>调试chrome safari浏览器的H5页面</h4><p>注意关闭翻墙代理噢。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于weinre 开发的一款APP， 只针对ios手机。大概使用方式是在APP内打开需要调试的页面，相应的在pc端浏览器会出现调试器，方可进行调试。<br>使用MIHTool的最大优点之一在于不需要显式的引入调试所需的脚本。在此基础上，作者还增加了一些方便的功能。</p><h4 id="1-Performance-API"><a href="#1-Performance-API" class="headerlink" title="1. Performance API."></a>1. Performance API.</h4><h4 id="2-Polyfill管理器-模拟javascript与Native-App互相调用-demo"><a href="#2-Polyfill管理器-模拟javascript与Native-App互相调用-demo" class="headerlink" title="2. Polyfill管理器(模拟javascript与Native App互相调用,demo)"></a>2. Polyfill管理器(模拟javascript与Native App互相调用,demo)</h4><h4 id="3-NPM-Modules-在-web-inspector-console-里通过-require-加载-npm-模块"><a href="#3-NPM-Modules-在-web-inspector-console-里通过-require-加载-npm-模块" class="headerlink" title="3. NPM Modules (在 web inspector console 里通过 require() 加载 npm 模块)"></a>3. NPM Modules (在 web inspector console 里通过 require() 加载 npm 模块)</h4><p>具体可以看官网：<a href="http://www.mihtool.com/" target="_blank" rel="noopener">http://www.mihtool.com/</a></p><blockquote><p>4、ios模拟器 + mac safari</p></blockquote><h4 id="调试safari浏览器的H5页面（可进行js断点调试）"><a href="#调试safari浏览器的H5页面（可进行js断点调试）" class="headerlink" title="调试safari浏览器的H5页面（可进行js断点调试）"></a>调试safari浏览器的H5页面（可进行js断点调试）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在没有真机的情况下，可以采用模拟机的方式去运行ios系统下的safari浏览器，然后在safari浏览器内输入想要调试的页面。当然模拟ios系统必须在Xcode这个开发软件下进行。一旦在Xcode里开启了模拟机，再进入模拟机里的safari，之后按照上边介绍过的真机 safari + mac safari介绍的方式进行操作便可。</p><p><img src="http://cdn1.showjoy.com/images/ab/ab12718e529e4f03b1e17091e592b694.png" alt="a"></p><blockquote><p>5、ios模拟器 + mac safari</p></blockquote><h4 id="调试公司APP内的webview页面（可进行js断点调试）"><a href="#调试公司APP内的webview页面（可进行js断点调试）" class="headerlink" title="调试公司APP内的webview页面（可进行js断点调试）"></a>调试公司APP内的webview页面（可进行js断点调试）</h4><p>参考 <a href="https://github.com/paulirish/iOS-WebView-App" target="_blank" rel="noopener">https://github.com/paulirish/iOS-WebView-App</a>，因为不懂IOS开发，也不知道是如何进行的，但大概是在iOS项目内写一些方法抛出一个地址，然后在mac上的safari开发模式内识别出这个地址，然后就可以调试的。默认情况下，mac safari只能识别usb连接的ios设备上的safari浏览器上的H5页面。（上面介绍过）</p><h1 id=""><a href="#" class="headerlink" title="==========================================="></a>===========================================</h1><h3 id="Android-设备"><a href="#Android-设备" class="headerlink" title="Android 设备"></a><span style="color:red">Android 设备</span></h3><blockquote><p>1、Android chrome 真机 + pc chrome</p></blockquote><h4 id="调试移动端浏览器的H5页面（可进行js断点调试）"><a href="#调试移动端浏览器的H5页面（可进行js断点调试）" class="headerlink" title="调试移动端浏览器的H5页面（可进行js断点调试）"></a>调试移动端浏览器的H5页面（可进行js断点调试）</h4><p>在安卓4.4版本以下的安卓机子，手机上安装了chrome的情况下，并且打开需要调试的页面，可以打开usb开发者模式，在pc端chrome地址栏输入chrome://inspect便可找到相应的手机的相应打开wap页面。调试方法跟pc chrome几乎一致。</p><p>在第一次使用的时候点击inspect会弹出空白的调试页面，这个时候需要翻墙，再点inspect才会出现正常的调试页面。</p><h4 id="优点：可进行js断点调试。"><a href="#优点：可进行js断点调试。" class="headerlink" title="优点：可进行js断点调试。"></a>优点：可进行js断点调试。</h4><h4 id="缺点：浏览器限制。"><a href="#缺点：浏览器限制。" class="headerlink" title="缺点：浏览器限制。"></a>缺点：浏览器限制。</h4><h4 id="调试公司APP内的webview页面（可进行js断点调试）-1"><a href="#调试公司APP内的webview页面（可进行js断点调试）-1" class="headerlink" title="调试公司APP内的webview页面（可进行js断点调试）"></a>调试公司APP内的webview页面（可进行js断点调试）</h4><p>在安卓4.4版本以上的安卓机子，手机通过usb连接mac电脑后，手机打开usb开发者模式后，在电脑chrome的chrome://inspect页面里会找到除了手机浏览器打开的页面，还会找到App内打开的webview的页面。</p><p><img src="http://cdn1.showjoy.com/images/ce/ce98e4652b7f47c99612a3081e4e785f.png" alt="a"></p><p>点开<code>inspect</code>就是一个调试界面。</p><p>进行webview页面的调试 需要在应用的代码内设置才能生效（根据<a href="https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md#%E8%B0%83%E8%AF%95-webviews" target="_blank" rel="noopener">https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md#%E8%B0%83%E8%AF%95-webviews</a>）</p><blockquote><p>2、Android 模拟机 + pc chrome</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;安卓模拟机配置成功的情况下调试的方式跟上面1方法是一样的，在安卓4.4版本以上才能进行webview的调试。<br>&nbsp;&nbsp;&nbsp;&nbsp;下面就介绍下大名鼎鼎的安卓模拟器genymotion.个人使用是免费的。</p><ol><li>在其官网注册（必须）<a href="https://www.genymotion.com/" target="_blank" rel="noopener">https://www.genymotion.com/</a></li><li>在其官网下载最新的软件，下载完将genymotion和genymotion shell都放到应用程序内。</li><li>下完这个之后还需要下载virtualBox，<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">https://www.virtualbox.org/wiki/Downloads</a></li><li>之后就可以选择不同版本的模拟器了，网上的教程都是推荐下载安卓4.3版本，因为4.3版本有对应的补丁，装上后可以避免一些应用下载失败。但4.3版本不支持调试webview。我推荐下载 HTC one 4.4.4版本，本人试了很多版本，只有这个可以调试我司App内嵌的H5页面。</li></ol><p><img src="http://cdn1.showjoy.com/images/b3/b38d848454e34984a0436989c4847139.png" alt="a"></p><p>推荐一个专门讲解genymotion的资源。<br><a href="http://www.ziliao1.com/Article/Show/DCDFC03FE4902A1AC353C74695DAC2E9.html" target="_blank" rel="noopener">http://www.ziliao1.com/Article/Show/DCDFC03FE4902A1AC353C74695DAC2E9.html</a><br>以及模拟机版本下载失败的解决办法<br><a href="http://www.cnblogs.com/wliangde/p/3678649.html" target="_blank" rel="noopener">http://www.cnblogs.com/wliangde/p/3678649.html</a></p><blockquote><p>3、万金油 weinre + pc chrome</p></blockquote><h4 id="调试任意浏览器的H5页面以及webview页面-1"><a href="#调试任意浏览器的H5页面以及webview页面-1" class="headerlink" title="调试任意浏览器的H5页面以及webview页面"></a>调试任意浏览器的H5页面以及webview页面</h4><p>这个方法在之上iOS 部分已经讲解过了。weinre通吃安卓与ios，兼容性不要太高。</p><blockquote><p>4、微信调试</p></blockquote><h4 id="调试微信客户端的webview页面（支持js断点调试）"><a href="#调试微信客户端的webview页面（支持js断点调试）" class="headerlink" title="调试微信客户端的webview页面（支持js断点调试）"></a>调试微信客户端的webview页面（支持js断点调试）</h4><p>目前微信已经出了官方的调试工具，照着做就好了。<br><a href="http://blog.qqbrowser.cc/" target="_blank" rel="noopener">http://blog.qqbrowser.cc/</a></p><blockquote><p>5、UC浏览器 + 真机 + mac chrome</p></blockquote><h4 id="调试uc浏览器的H5页面（支持js断点）"><a href="#调试uc浏览器的H5页面（支持js断点）" class="headerlink" title="调试uc浏览器的H5页面（支持js断点）"></a>调试uc浏览器的H5页面（支持js断点）</h4><p>方法一是真机加上chrome浏览器，这个方法是真机加uc浏览器，<br><a href="http://www.uc.cn/business/developer/" target="_blank" rel="noopener">http://www.uc.cn/business/developer/</a></p><p>++++++++++++++++++++++++++++++++++<br>++++++++++++++++++++++++++++++++++</p><p><span style="color:red">总结</span></p><h4 id="上面罗列的多种方法，在本地开发的情况下基本都已经覆盖到了。但是如果线上页面出现bug了。该怎么办？最快的方法直接对线上页面进行调试。"><a href="#上面罗列的多种方法，在本地开发的情况下基本都已经覆盖到了。但是如果线上页面出现bug了。该怎么办？最快的方法直接对线上页面进行调试。" class="headerlink" title="上面罗列的多种方法，在本地开发的情况下基本都已经覆盖到了。但是如果线上页面出现bug了。该怎么办？最快的方法直接对线上页面进行调试。"></a>上面罗列的多种方法，在本地开发的情况下基本都已经覆盖到了。但是如果线上页面出现bug了。该怎么办？最快的方法直接对线上页面进行调试。</h4><p>先介绍一下mac抓包工具<code>charles</code></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=400497314&idx=1&sn=850fad741fdb635c2403bafb2f1e636f&scene=1&srcid=1119TqsnfhBHSKzA2BUja9mk&key=ac89cba618d2d97693fea624e810ff69a7385f5209ab2a26ec029ca8f618e760e87de444299655bad41c5d1a7dbbc76e&ascene=0&uin=Mjg1NTY1OTY2MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46" target="_blank" rel="noopener">charles 教程</a></p><p>1、截取http网络封包<br>2、支持修改网络请求参数<br>3、支持网络请求的截获并动态修改<br>4、支持重发网络请求<br>5、模拟网速网络</p><p>刚刚给出的链接中有charles的全方位解读，我这里就简单介绍下http网络封包。</p><p>在pc上charles可以很容易的创建一个代理，将设定的一部分网络请求全部转到charles代理上，并且可以将其中某个资源map到本地，从而实现使用本地代码调试线上代码的功能。</p><p>但是我们现在是调试手机等移动端设备，但稍微做一些设置，就可以实现通过pc上的charles去代理移动端去请求资源。然后将需要的资源map到本地，进行修改和调试。</p><p>这样设置过后的效果就是，在pc端修改代码，移动端线上的页面去请求本地修改后的代码并展示。</p><p>讲完了charles,问题回到如何快速调试线上页面。</p><h4 id="如果是H5页面"><a href="#如果是H5页面" class="headerlink" title="如果是H5页面"></a>如果是H5页面</h4><p>遇上H5页面在PCchrome调试器上跟真实手机上的效果不一致时，可以使用万金油weinre，结合charles，就可以调试这种机型各种浏览器上的问题了。当然也可以使用上面提到的其他方法，都是适用的。</p><h4 id="如果是webview"><a href="#如果是webview" class="headerlink" title="如果是webview"></a>如果是webview</h4><p>同样不能少的是charles抓包，如果是安卓可以配合genymotion模拟器进行模拟。使用方法上文讲述过，再推荐一篇专门的文章：<a href="http://div.io/topic/1449。这篇文章讲到如何用charles监听genymotion。" target="_blank" rel="noopener">http://div.io/topic/1449。这篇文章讲到如何用charles监听genymotion。</a><br>如果是ios，也可以采用这样的方式，即模拟器+charles+mac safari。使用方法在上文的ios章节讲述过。<br>当然也是可以使用万金油weinre。weinre+charles调试App内的H5页面也是很方便的。跟上面两种方法比较，缺少的就是js断点调试功能。</p><p>===========================================</p><h4 id="声明-本文转载自lvdada的博客"><a href="#声明-本文转载自lvdada的博客" class="headerlink" title="声明:本文转载自lvdada的博客"></a>声明:本文转载自<a href="http://lvdada.org/2015/12/20/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/" target="_blank" rel="noopener">lvdada的博客</a></h4><h4 id="完！"><a href="#完！" class="headerlink" title="完！"></a>完！</h4><h4 id="借鉴-原创文章，转载请注明出处！"><a href="#借鉴-原创文章，转载请注明出处！" class="headerlink" title="借鉴+原创文章，转载请注明出处！"></a>借鉴+原创文章，转载请注明出处！</h4>]]></content>
      
      
      <categories>
          
          <category> web调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> web调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS日期格式化转换方法</title>
      <link href="/2017/05/06/JS%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/"/>
      <url>/2017/05/06/JS%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><h5 id="将日期转换为指定的格式：比如转换成-年月日时分秒-这种格式：yyyy-MM-dd-hh-mm-ss-或者-yyyy-MM-dd"><a href="#将日期转换为指定的格式：比如转换成-年月日时分秒-这种格式：yyyy-MM-dd-hh-mm-ss-或者-yyyy-MM-dd" class="headerlink" title="将日期转换为指定的格式：比如转换成 年月日时分秒 这种格式：yyyy-MM-dd hh:mm:ss 或者 yyyy-MM-dd"></a>将日期转换为指定的格式：比如转换成 年月日时分秒 这种格式：yyyy-MM-dd hh:mm:ss 或者 yyyy-MM-dd</h5></blockquote><pre><code class="javascript">Date.prototype.format = function (fmt) {  var o = {    &#39;M+&#39;: this.getMonth() + 1, //月份    &#39;d+&#39;: this.getDate(), //日    &#39;h+&#39;: this.getHours(), //小时    &#39;m+&#39;: this.getMinutes(), //分    &#39;s+&#39;: this.getSeconds(), //秒    &#39;q+&#39;: Math.floor((this.getMonth() + 3) / 3), //季度    S: this.getMilliseconds(), //毫秒  }  if (/(y+)/.test(fmt)) {    fmt = fmt.replace(      RegExp.$1,      (this.getFullYear() + &#39;&#39;).substr(4 - RegExp.$1.length)    )  }  for (var k in o) {    if (new RegExp(&#39;(&#39; + k + &#39;)&#39;).test(fmt)) {      fmt = fmt.replace(        RegExp.$1,        RegExp.$1.length == 1 ? o[k] : (&#39;00&#39; + o[k]).substr((&#39;&#39; + o[k]).length)      )    }  }  return fmt}//调用var time1 = new Date().format(&#39;yyyy-MM-dd hh:mm:ss&#39;)console.log(time1)//或var time2 = new Date().format(&#39;yyyy-MM-dd&#39;)console.log(time2)</code></pre><a id="more"></a><blockquote><h5 id="将指定的日期转换为”年月日”的格式，代码如下："><a href="#将指定的日期转换为”年月日”的格式，代码如下：" class="headerlink" title="将指定的日期转换为”年月日”的格式，代码如下："></a>将指定的日期转换为”年月日”的格式，代码如下：</h5></blockquote><pre><code class="javascript">var oldTime = new Date(&#39;2012/12/25 20:11:11&#39;).getTime()var curTime = new Date(oldTime).format(&#39;yyyy-MM-dd&#39;)console.log(curTime)</code></pre><blockquote><h5 id="将-“时间戳”-转换为-“年月日”-的格式"><a href="#将-“时间戳”-转换为-“年月日”-的格式" class="headerlink" title="将 “时间戳” 转换为 “年月日” 的格式."></a>将 “时间戳” 转换为 “年月日” 的格式.</h5></blockquote><pre><code class="javascript">var da = 1402233166999da = new Date(da)var year = da.getFullYear() + &#39;年&#39;var month = da.getMonth() + 1 + &#39;月&#39;var date = da.getDate() + &#39;日&#39;console.log([year, month, date].join(&#39;-&#39;))</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angular中的工具方法总结</title>
      <link href="/2017/03/02/angular-gongjufangfa/"/>
      <url>/2017/03/02/angular-gongjufangfa/</url>
      
        <content type="html"><![CDATA[<h5 id="工具方法："><a href="#工具方法：" class="headerlink" title="工具方法："></a>工具方法：</h5><hr><ol><li><p><code>angular.bind(obj1,obj)</code> —改变this指向<br> 参数方法: <code>obj1</code>: 改变后this指向的对象  <code>obj</code>: 被改变的对象  </p><pre><code class="javascript"> function show (){     alert(this); } show(); angular.bind(document,show)();  //改变this指向  </code></pre><a id="more"></a></li><li><p><code>angular.extend(a,b)</code> — 继承方法<br> 参数方法：<code>a</code>:继承者  <code>b</code>:被继承</p><pre><code class="javascript"> var a = {      name:&#39;hello&#39;  }  var b = {      age:&#39;20&#39;  }  var c = angular.extend(b,a) ;  //将a 给了 b  console.log(c); // {name:&#39;hello&#39;,age:&#39;20&#39;}</code></pre></li><li><p><code>angular.copy(a,b)</code> — 拷贝方法<br> 参数方法：将a的所有值赋给了b，并且取代覆盖了b</p><pre><code class="javascript"> //结构代码同上  var c = angular.copy(a,b);    console.log(c); // {name:&#39;hello&#39;}  console.log(a); // {name:&#39;hello&#39;}  console.log(b); // {name:&#39;hello&#39;}</code></pre></li><li><p><code>angular.isArray(需要判断的元素)</code> –是否为数组</p></li><li><p><code>angular.isDate()</code> –是否为日期对象</p></li><li><p><code>angular.isDefined()</code> –元素是否被定义</p></li><li><p><code>angular.isUnDefined()</code>  –元素是否未被定义</p></li><li><p><code>angular.isFunction()</code> –判断是否为function</p></li><li><p><code>angular.isNumber()</code></p></li><li><p><code>angular.isObject()</code></p></li><li><p><code>angular.isString()</code></p></li><li><p><code>angular.isElement(元素)</code></p></li><li><p><code>angular.version</code> – 输出当前使用的angular版本</p></li><li><p><code>angular.forEach(obj,fn,result)</code><br>参数说明：<code>obj</code>:被便利的数组或者对象   <code>fn(value,i)</code>:遍历后的回调函数  <code>result</code>:想要返回的结果</p><pre><code class="javascript">var a = {    name:&#39;zhang&#39;,    sex:&#39;boy&#39;}var result = [] ;angular.forEach(a,function(value,i){    console.log(&#39;value:&#39;+value+&#39;\n&#39;+&#39;i:&#39;+i);    console.log(this) ; //this指的是结果数组    this.push(value);},result)console.log(result); // [zhang,boy];</code></pre></li><li><p><code>angular.fromJson/toJson</code> – 对字符串格式的json 进行解析  和对json进行字符串转换，类似于原生JSON.parse()  JSON.stringify()</p><pre><code class="javascript">//angular.fromJson()var str = &#39;{&quot;name&quot;:&quot;hello&quot;,&quot;age&quot;:&quot;18&quot;}&#39; ;var json = angular.fromJson(str);console.log(json); // {name:hello,age:18}//angular.toJson()var json = {&quot;name&quot;:&quot;hello&quot;,&quot;age&quot;:&quot;18&quot;};var str = angular.toJson(json,true);  //true:表示按照格式打印console.log(str) // &quot;{&quot;name&quot;:&quot;hello&quot;,&quot;age&quot;:&quot;18&quot;}&quot;</code></pre></li><li><p><code>angular.lowercase()/uppercase()</code>  – 大小写转换</p></li><li><p><code>angular.element()</code> – angular 中封装的jq方法  具体方法参考<a href="https://docs.angularjs.org/api/ng/function/angular.element" target="_blank" rel="noopener">angular文档</a></p><pre><code class="javascript">var oDiv = document.getElementById(&#39;div&#39;);angular.element(oDiv).css(&#39;backgroud&#39;,&#39;red&#39;)</code></pre><pre><code class="html">&lt;div id=&#39;div&#39;&gt;&lt;/div&gt;</code></pre></li><li><p><code>angular.bootstrap</code> –angular 动态初始化angular 相同于 指令<code>ng-app</code><br>好处:可以在想要初始化的时候去执行初始化,针对多个angular初始化会同时初始化</p><pre><code class="javascript">angular.bootstrap(document,[&#39;myapp&#39;,&#39;myapp1&#39;])</code></pre></li><li><p><code>angular.injector</code> – 在angular内部使用，注册器</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atom 编辑器快捷键</title>
      <link href="/2017/02/23/Atom-%E7%BC%96%E8%BE%91%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2017/02/23/Atom-%E7%BC%96%E8%BE%91%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>快捷键</p></blockquote><p><code>cmd+shift+c</code> ：调取color Picker<br><code>cmd+shift+P</code> :    调取命令行<br>      <code>cmd-shift-D</code>: 复制当前行到下一行<br>      cmd-L 选取一行，继续按回选取下一行<br>      cmd+,    打開包管理</p><p><a href="https://github.com/shery15/awesome-atom-packages/blob/master/README-zh.md" target="_blank" rel="noopener">Atom優秀的插件</a></p><p><a href="http://www.jianshu.com/p/dd97cbb3c22d" target="_blank" rel="noopener">優秀插件</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symbol数据类型</title>
      <link href="/2016/10/21/Symbol%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2016/10/21/Symbol%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>什么是Symbol 数据类型？</p></blockquote><ol><li><p><strong>MDN</strong> 的解释：</p><pre><code>Symbol()函数会返回symbol类型的值，每个从Symbol()返回的symbol值都是唯一的， 一个symbol值能作为对象属性的标识符； 这是该数据类型仅有的目的。</code></pre><ol start="2"><li><p>个人理解：</p><p>Symbol类型是es6新增的一个数据类型,Es5的基本数据类型（undefined，null,Object,function,Number,string）Symbol值通过Symbol函数生成Symbol类型是保证每个属性的名字都是独一无二的，对于一个对象由对个模块构成的情况非常有用 。</p></li></ol></li></ol><a id="more"></a><blockquote><p>怎么使用?</p></blockquote><p><strong>值的输出：</strong></p><pre><code class="javascript">var a=Symbol(‘foo’)=&gt;Symbol(foo) //与其他类型不能运算，可以转换成字符串</code></pre>]]></content>
      
      
      <categories>
          
          <category> EcmaJs6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decorators 修饰器</title>
      <link href="/2016/10/17/Decorators-%E4%BF%AE%E9%A5%B0%E5%99%A8/"/>
      <url>/2016/10/17/Decorators-%E4%BF%AE%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简介：修饰器是一个函数，用于修饰类的行为（修改 扩展类的功能，修饰器只在类的范围使用）。</p></blockquote><p> 需安装：npm install babel-plugin-transform-decorators-legacy –save-dev</p><h4 id="1-限制某个属性-是只读的"><a href="#1-限制某个属性-是只读的" class="headerlink" title="1.限制某个属性 是只读的"></a>1.限制某个属性 是只读的</h4><pre><code class="javascript">{     let readonly = function(target,name,descriptor){         // target :修改的类本身         // name ： 属性本身         // descriptor ：属性的描述对象         descriptor.writable = false ;  //只读效果         return descriptor ;     }     class Test {         @readonly  // 修饰器         time(){             return &#39;2018-01-01&#39; ;         }     }     let test=new Test();      test.time=function(){       console.log(&#39;reset time&#39;);      };     console.log(test.time()) ;  //  报错 }</code></pre><a id="more"></a><h4 id="2-在类的外面-使用修饰器-（必须在class的前面使用）"><a href="#2-在类的外面-使用修饰器-（必须在class的前面使用）" class="headerlink" title="2.在类的外面 使用修饰器  （必须在class的前面使用）"></a>2.在类的外面 使用修饰器  （必须在class的前面使用）</h4><pre><code class="javascript">{  let typename=function(target,name,descriptor){    target.myname=&#39;hello&#39;;  }  @typename  class Test{  }  console.log(&#39;类修饰符&#39;,Test.myname);  // 第三方库修饰器的js库：core-decorators; npm install core-decorators}</code></pre><blockquote><p>埋点系统</p></blockquote><pre><code class="javascript">// 案例1// 日志系统 ： 传统 将埋点写到业务逻辑中{  let log =(type)=&gt;{    return function(target,name,descriptor){      let src_method = descriptor.value ;      descriptor.value =(...arg)=&gt;{        src_method.apply(target,arg);        console.info(`log ${type}`);      }    }  }  class AD{    @log(&#39;show&#39;)    show(){      console.info(&#39;ad is show&#39;) ;    }    click(){      console.info(&#39;ad is click&#39;) ;    }  }  let ad = new AD() ;  ad.show();  ad.click();}// 好处：埋点抽离出来   </code></pre>]]></content>
      
      
      <categories>
          
          <category> EcmaJs6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Es6 模块化</title>
      <link href="/2016/09/01/Es6-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2016/09/01/Es6-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基本概念</p></blockquote><p>&nbsp;</p><a id="more"></a><blockquote><p>语法</p></blockquote><pre><code class="javascript">// A文件// 作为一个模块   1.导出变量  2.导出函数  3.类暴露出去//第一种写法export let A = 123 ;export function test(argument) {    // body...    console.log(&#39;test&#39;) ;}export class Hello{    test(){        console.log(&#39;class&#39;) ;    }}//推荐使用第二种写法let A = 123 ;let test = function(){    console.log(&#39;test&#39;) ;}class Hello{    test(){        console.log(&#39;class&#39;) ;    }}export default {  A,  test,  Hello}//B 文件//第一种写法import(A,test,Hello) from &#39;A文件地址&#39; ;console.log(A,test,Hello) ;//第二种写法import * as lesson from &#39;./class/lesson17&#39; ;console.log(lesson.A,lesson.test,lesson.Hello) ;//推荐使用第三种写法import lesson17 from &#39;./class/lesson17&#39; ;console.log(lesson17.A,lesson17.test,lesson17.Hello) ;</code></pre>]]></content>
      
      
      <categories>
          
          <category> EcmaJs6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Iterator 和 for...of 循环</title>
      <link href="/2016/08/23/Iterator-%E5%92%8C-for-of-%E5%BE%AA%E7%8E%AF/"/>
      <url>/2016/08/23/Iterator-%E5%92%8C-for-of-%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>什么是Iterator接口</p></blockquote><p>用于数组 对象  map set 等数据集合的<strong>统一</strong>读取操作，不同的数据结构，通过for…of这种形式，达到读取的目标，但是背后的iterator接口是不一样的。</p><blockquote><p><strong>MDN解释</strong>:<br>当需要迭代一个对象的时候（比如在 <code>for...of</code> 循环的开始时），它的 <code>@@iterator</code> 方法就会被调用一次（0 个参数），同时返回的迭代器将被用来获取被迭代出来的值。</p></blockquote><p><code>for of</code>  循环：不断调用iterator接口。</p><a id="more"></a><h5 id="示例1：-iterator数组的读取"><a href="#示例1：-iterator数组的读取" class="headerlink" title="示例1：  iterator数组的读取"></a>示例1：  iterator数组的读取</h5><pre><code class="javascript">{    let arr = [&#39;hello&#39;,&#39;world&#39;];    let map = arr[Symbol.iterator]();    console.log(map.next());    console.log(map.next());    console.log(map.next());}</code></pre><p>上述代码中：</p><ol><li>返回结果：</li></ol><p><img src="https://app.yinxiang.com/shard/s72/res/b1a5c863-d3d1-4605-9119-afba59b66cf9" alt="Alt text"></p><p><strong>说明</strong>：结果<strong>返回一个对象</strong>，包含 <code>value</code>  和 <code>done</code> 两个参数，如果 <code>done==false</code>  说明 循环还有下一步状态，如果没有了，即不再有value ；</p><blockquote><p>给一个复杂数据结构部署 <code>iterator</code> 接口,使其可以支持for….of 循环<br>另外：还有一种方式：使用generator生成器 详见笔记:  <strong><em>Generator生成器</em></strong></p></blockquote><pre><code class="javascript">// object 没有部署  iterator 接口，没有iterator 接口，现在要obj 部署iterator 可以用for of 循环  --------自定义iterator接口部署{  let obj={    start:[1,3,2],    end:[7,9,8],    [Symbol.iterator](){      let self=this;      console.log(this)      let index=0;      let arr=self.start.concat(self.end);      console.log(arr)      let len=arr.length;      console.log(len) ;      return {        next(){          if(index&lt;len){              console.log(&quot;index&quot;+index)              console.log(arr[index++])            return {              value:arr[index++],// 必须保证index +1 ，进行下一步              done:false            }          }else{            return {              value:arr[index++],              done:true            }          }        }      }    }  }  for(let key of obj){      console.log(&#39;***********************&#39;)    console.log(key);  }}</code></pre><p><b>运行结果：</b></p><p><img src="https://app.yinxiang.com/shard/s72/res/422356a2-06b9-43f1-98d0-e1216c0b33a9" alt="Alt text | center "></p>]]></content>
      
      
      <categories>
          
          <category> EcmaJs6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Generator 生成器</title>
      <link href="/2016/08/23/Generator-%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2016/08/23/Generator-%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>什么是 <strong>Generator</strong>？</p></blockquote><p>解决异步编程 ：<br>&nbsp;&nbsp;&nbsp;&nbsp; Generator 包含多个步骤，每个步骤包含<code>yield</code> 或者 <code>return</code>  ，遇到就会停止，进行下一步，调用<code>next()</code>函数 。</p><blockquote><p>基本用法：</p></blockquote><pre><code class="javascript">{    // Generator 基本用法    let tell=function* (){    yield &#39;a&#39;;    yield &#39;b&#39;;border-left: 5px solid gray;    return &#39;c&#39;      };  let k=tell();  console.log(k.next());  console.log(k.next());  console.log(k.next());  console.log(k.next());}</code></pre><a id="more"></a><blockquote><p><strong>generator 函数  和  iterator 接口的关系 ：</strong></p></blockquote><blockquote><p>任何一个对象的iterator接口都是部署到Symbol.iterator属性上，generator就是遍历器的生成函数，所以可以直接把generator直接赋值给Symbol.iterator，从而使得对象也具备了iterator接口。</p></blockquote><pre><code class="javascript">{  let obj={};  obj[Symbol.iterator]=function* (){    yield 1;    yield 2;    yield 3;  }  for(let value of obj){    console.log(&#39;value&#39;,value);  }}</code></pre><blockquote><p><strong>状态机</strong>  ： 比如使用A、B、C 描述一个事物三种状态。用Generator 处理特别适用。</p></blockquote><pre><code class="javascript">{  let state=function* (){    //当状态为1 的时候 不断next() 可以循环状态    while(1){      yield &#39;A&#39;;      yield &#39;B&#39;;      yield &#39;C&#39;;    }  }  let status=state();  console.log(status.next());  console.log(status.next());  console.log(status.next());  console.log(status.next());  console.log(status.next());}</code></pre><p><strong>结果：</strong></p><p><img src="https://app.yinxiang.com/shard/s72/res/326cd889-605a-48b8-8504-019b36da5092" alt="Alt text | center"></p><blockquote><p>async 语法</p></blockquote><h4 id="实例1：抽奖次数限制"><a href="#实例1：抽奖次数限制" class="headerlink" title="实例1：抽奖次数限制"></a>实例1：抽奖次数限制</h4><pre><code class="javascript">{    // 抽奖逻辑 和 次数限制  分离    let draw = function(count){        //具体逻辑        console.info(`剩余${count}次数`);    }    draw(1)    // 计算当前的次数   之前使用全局变量保存当前次数，这样会非常不安全      // generator    let residue = function* (count){        while(count&gt;0){ // 次数限制限制            count -- ;            yield draw(count) ; //抽奖逻辑        }    }    let star = residue (5) ;    let btn = document.createElement(&#39;button&#39;) ;    btn.id = &#39;start&#39; ;    btn.textContent = &quot;抽奖&quot; ;    document.body.appendChild(btn) ;    document.getElementById(&#39;start&#39;).addEventListener(&#39;click&#39;,function(){        star.next() ;    },false)}</code></pre><p><strong>结果：</strong></p><p><img src="https://app.yinxiang.com/shard/s72/res/1e0566ee-6bb8-4d67-9e1c-cb73b82ebfa3" alt="Alt text | center"></p><h4 id="实例2：长轮询的generator实现"><a href="#实例2：长轮询的generator实现" class="headerlink" title="实例2：长轮询的generator实现"></a>实例2：长轮询的generator实现</h4><pre><code class="javascript">// 实例2   长轮询 ： 服务端数据 定期变化，前端 需要定时去取。之前 通过定时器不断的取  现在使用 generator{    let ajax = function* (){        yield new Promise(function(resolve,reject){            setTimeout(function(){                resolve({code:0})            },200) ;        })    }    // 长轮询    let pull = function(){        var generator = ajax() ;        let step = generator.next() ;        step.value.then(function(d){            console.log(d) ;            if(d.code !=0){                setTimeout(function(d){                    console.log(&#39;wait&#39;) ;                    pull() ;                },1000)            }else{                console.log(d) ;            }        })    }    pull() ;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> EcmaJs6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object.assign</title>
      <link href="/2016/08/18/Object.assign/"/>
      <url>/2016/08/18/Object.assign/</url>
      
        <content type="html"><![CDATA[<p>Es5中实现</p><pre><code class="javascript">    //对象assign 方法var createAssigner = function(keysFunc,defaults){  return function(obj){    var length = arguments.lenth;    if(defaults) obj = Object(obj);    if(length&lt;2||obj==null) return obj ;    for(var index=1;index.length;index++){      var source = arguments[index],keys = keysFunc(source),l = keys.length;      for(var i = 0;i&lt;l;i++){        var key = keys[i];        if(!defaults || obj[key] == void 0)          obj[key] = source[key];      }    }    return obj;  }}var allkeys = function(obj){  var keys = [];  for(var key in obj) keys.push(key);  return keys ;}var extend = createAssigner(allkeys);extend({t:1},{k:2})</code></pre><a id="more"></a><p>Es6中实现</p><pre><code class="javascript">Object.assign({t:1},{t:2}) ;</code></pre>]]></content>
      
      
      <categories>
          
          <category> EcmaJs6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise 异步编程的解决方案</title>
      <link href="/2016/08/09/Promise-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2016/08/09/Promise-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>promise概念：异步编程解决方案</p><p><strong>举例</strong>：函数A执行步骤——》执行完执行 B</p><p> 解决上述问题有两种方式：</p><ul><li>回调方式</li></ul><p><img src="https://app.yinxiang.com/shard/s72/res/575b47df-aace-4872-84dd-ef70325114c9" alt="Alt text"></p><ul><li>事件触发的方式</li></ul><a id="more"></a><blockquote><p>使用Promise</p></blockquote><pre><code class="javascript">{    // ES5  回调解决异步   模拟ajax    // 基本定义  let ajax=function(callback){    console.log(&#39;执行&#39;);    setTimeout(function () {      callback&amp;&amp;callback.call()    }, 1000);  };  ajax(function(){    console.log(&#39;timeout1&#39;);  })}{  let ajax=function(){    console.log(&#39;执行2&#39;);    return new Promise(function(resolve,reject){      // resolve:执行下一步操作   reject:终止操作      setTimeout(function () {        resolve()      }, 1000);    })  };  ajax().then(function(){    console.log(&#39;promise&#39;,&#39;timeout2&#39;);  })  // 执行步骤 ：  //    1.运行Ajax方法  //    2. 运行完之后返回一个Promise 实例，promise实例有resolve，reject方法}// 多个任务  {  let ajax=function(){    console.log(&#39;执行3&#39;);    return new Promise(function(resolve,reject){      setTimeout(function () {        resolve()      }, 1000);    })  };  ajax()    .then(function(){    return new Promise(function(resolve,reject){      setTimeout(function () {        resolve()      }, 2000);    });  })    .then(function(){    console.log(&#39;timeout3&#39;);  })}// 多个任务捕获{  let ajax=function(num){    console.log(&#39;执行4&#39;);    return new Promise(function(resolve,reject){      if(num&gt;5){        resolve();      }else{        throw new Error(&#39;出错了&#39;)      }    })  }  ajax(6).then(function(){    console.log(&#39;log&#39;,6);  }).catch(function(err){    console.log(&#39;catch&#39;,err);  });  ajax(3).then(function(){    console.log(&#39;log&#39;,3);  }).catch(function(err){    console.log(&#39;catch&#39;,err);  });}{  // 所有图片加载完 再添加到页面  function loadImg(src){    // 此promise实例做图片加载的动作    return new Promise((resolve,reject)=&gt;{      let img = document.createElement(&#39;img&#39;);      img.src = src ;      img.onload =function(){        resolve(img);      }      img.onerror=function(err){        reject(err);      }    })  }  function showImgs(imgs){    imgs.forEach(function(img){      document.body.appendChild(img);    })  }  // Promise.all表示把多个promise实例当做一个来用。当所有promise实例状态发生改变，新的promise实例才会发生变化  Promise.all([    loadImg(&#39;http://shape-app.oss-cn-beijing.aliyuncs.com/task_alarm/QMkieAh3Jj.png&#39;),    loadImg(&#39;http://shape-app.oss-cn-beijing.aliyuncs.com/activity_test/pAPrTzNMMF.jpg&#39;),    loadImg(&#39;http://shape-app.oss-cn-beijing.aliyuncs.com/activity_test/5kZ7fCeabd.jpg&#39;),    loadImg(&#39;http://shape-app.oss-cn-beijing.aliyuncs.com/activity_test/2QwsHcpWZG.jpg&#39;)  ]).then(showImgs)}{  // 场景：三张不同的图片，位于三个不同的位置，页面需要加载一张图片，不知道三张图片哪个返回快，不关心，但是有三个来源，加载一个就可以，先到先得，哪个回来哪个显示  // 有一个加载完就显示的到页面  function loadImg(src){    // 此promise实例做图片加载的动作    return new Promise((resolve,reject)=&gt;{      let img = document.createElement(&#39;img&#39;);      img.src = src ;      img.onload =function(){        resolve(img);      }      img.onerror=function(err){        reject(err);      }    })  }  function showImgs(img){    let p = document.createElement(&#39;p&#39;);    p.appendChild(img);    document.body.appendChild(p);  }  // Promise.race  只要数组中有一个状态改变，就会触发新的promise实例。其他就不改变了   Promise.race([    loadImg(&#39;http://shape-app.oss-cn-beijing.aliyuncs.com/task_alarm/QMkieAh3Jj.png&#39;),    loadImg(&#39;http://shape-app.oss-cn-beijing.aliyuncs.com/activity_test/pAPrTzNMMF.jpg&#39;),    loadImg(&#39;http://shape-app.oss-cn-beijing.aliyuncs.com/activity_test/5kZ7fCeabd.jpg&#39;),    loadImg(&#39;http://shape-app.oss-cn-beijing.aliyuncs.com/activity_test/2QwsHcpWZG.jpg&#39;)  ]).then(showImgs)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> EcmaJs6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页ICON 优化</title>
      <link href="/2016/01/22/webIcon/"/>
      <url>/2016/01/22/webIcon/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Css Sprite</strong></p></blockquote><p><img src="https://app.yinxiang.com/shard/s72/res/d1f9917c-1bac-4b65-9d48-0d1155ef9a44" alt="Alt text"></p><blockquote><p>*<em>Icon Font *</em></p></blockquote><p><img src="https://app.yinxiang.com/shard/s72/res/669e5e00-8c8b-4e44-853e-aba7ef3fc499" alt="Alt text"></p><p><img src="https://app.yinxiang.com/shard/s72/res/21a4616f-85ba-4514-8878-392a0b6cabc0" alt="Alt text"></p><p><img src="https://app.yinxiang.com/shard/s72/res/961b8eda-7fb8-47eb-b667-957ababb813a" alt="Alt text"></p><p><img src="https://app.yinxiang.com/shard/s72/res/aee97199-8074-47d2-8b9b-ef26c0bc0e97" alt="Alt text"></p><a id="more"></a><blockquote><p>icomoon.io字体引入</p></blockquote><pre><code class="stylus">font-face  font-family: &#39;music-icon&#39;  src: url(&#39;../fonts/music-icon.eot?2qevqt&#39;)  src: url(&#39;../fonts/music-icon.eot?2qevqt#iefix&#39;) format(&#39;embedded-opentype&#39;),       url(&#39;../fonts/music-icon.ttf?2qevqt&#39;) format(&#39;truetype&#39;),       url(&#39;../fonts/music-icon.woff?2qevqt&#39;) format(&#39;woff&#39;),       url(&#39;../fonts/music-icon.svg?2qevqt#music-icon&#39;) format(&#39;svg&#39;)  font-weight: normal  font-style: normal  //匹配class中以icon-开头的  和   class中包含icon-的所有样式[class^=&quot;icon-&quot;], [class*=&quot; icon-&quot;]  /* use !important to prevent issues with browser extensions that change fonts */  font-family: &#39;music-icon&#39; !important  speak: none  font-style: normal  font-weight: normal  font-variant: normal  text-transform: none  line-height: 1  /* Better Font Rendering =========== */  // 用于webkit引擎中设置字体的抗锯齿，光滑度属性  -webkit-font-smoothing: antialiased  // 用于mac os系统中 火狐浏览器 抗锯齿属性  -moz-osx-font-smoothing: grayscale</code></pre><p><img src="https://app.yinxiang.com/shard/s72/res/396d9f7d-b3a4-4353-957f-672458711e45" alt="Alt text"></p><p><img src="https://app.yinxiang.com/shard/s72/res/88df8185-e4bf-4dd8-acdb-e042d6338295" alt="Alt text"></p><blockquote><h3 id="注意：由于使用icomoon-国外网站慢-so-可以使用-阿里巴巴矢量图库"><a href="#注意：由于使用icomoon-国外网站慢-so-可以使用-阿里巴巴矢量图库" class="headerlink" title="注意：由于使用icomoon 国外网站慢   so 可以使用 阿里巴巴矢量图库"></a>注意：由于使用icomoon 国外网站慢   so 可以使用 <a href="http://www.iconfont.cn/collections" target="_blank" rel="noopener">阿里巴巴矢量图库</a></h3></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断两个数组是否相等    &amp;&amp;   判断两个对象是否相等  </title>
      <link href="/2015/12/06/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89-%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/"/>
      <url>/2015/12/06/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89-%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">let obj1 = {  a: 1,  b: {    c: 2,    d: 3,  },}let obj2 = {  a: 1,  b: {    c: 2,    d: 3,  },}console.log(isEqual(obj1, obj2))function isObject(obj) {  return typeof obj === &#39;object&#39;}function isEqual(obj1, obj2) {  // 1.判断是不是对象，如果不是对象直接 === 出结果  if (!isObject(obj1) &amp;&amp; !isObject(obj2)) {    return obj1 === obj2  }  // 2. 如果是对象的话就先判断是不是直接 === 是的话直接返回 true  if (obj1 === obj2) {    return true  }  // 3. 如果2不通过 则开始深度遍历 并判断是否相等  //   3.1 先判断key的个数，如果个数不相等，就直接返回false ，如果相等 继续执行  let obj1Keys = Object.keys(obj1)  let obj2Keys = Object.keys(obj2)  if (obj1Keys.length !== obj2Keys.length) {    return false  }  //   3.2 以 obj1为基准  依次递归调用 与 obj2 做比较  for (let i in obj1) {    const res = isEqual(obj1, obj2)    if (!res) {      return false    }  }  return true}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
